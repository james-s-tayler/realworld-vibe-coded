name: CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

# Cancel in-progress runs for the same ref/PR to save minutes
concurrency:
  group: server-ci-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  pull-requests: write

jobs:
  build-server:
    name: Build (Server)
    runs-on: ubuntu-latest
    env:
      DOTNET_SKIP_FIRST_TIME_EXPERIENCE: 1
      DOTNET_CLI_TELEMETRY_OPTOUT: 1
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup .NET (from global.json)
        uses: actions/setup-dotnet@v4
        with:
          global-json-file: App/Server/global.json
          cache: true
          cache-dependency-path: "**/packages.lock.json"

      - name: Verify .NET version
        run: dotnet --info

      - name: Build (server)
        run: make build/server

  test-server:
    name: Test (Server)
    runs-on: ubuntu-latest
    # Run tests as an independent job so it shows up as its own status check
    env:
      DOTNET_SKIP_FIRST_TIME_EXPERIENCE: 1
      DOTNET_CLI_TELEMETRY_OPTOUT: 1
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup .NET (from global.json)
        uses: actions/setup-dotnet@v4
        with:
          global-json-file: App/Server/global.json
          cache: true
          cache-dependency-path: "**/packages.lock.json"

      - name: Verify .NET version
        run: dotnet --info

      - name: Test (server)
        run: make test/server

  lint-server:
    name: Lint (Server)
    runs-on: ubuntu-latest
    env:
      DOTNET_SKIP_FIRST_TIME_EXPERIENCE: 1
      DOTNET_CLI_TELEMETRY_OPTOUT: 1
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup .NET (from global.json)
        uses: actions/setup-dotnet@v4
        with:
          global-json-file: App/Server/global.json
          cache: true
          cache-dependency-path: "**/packages.lock.json"

      - name: Verify .NET version
        run: dotnet --info

      - name: Lint (server)
        run: make lint/server

  lint-make:
    name: Lint Makefile
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Run Makefile lint
        run: make lint/make

  test-server-postman:
    name: Test Server (Postman)
    runs-on: ubuntu-latest
    env:
      DOTNET_SKIP_FIRST_TIME_EXPERIENCE: 1
      DOTNET_CLI_TELEMETRY_OPTOUT: 1
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup .NET (from global.json)
        uses: actions/setup-dotnet@v4
        with:
          global-json-file: App/Server/global.json
          cache: true
          cache-dependency-path: "**/packages.lock.json"

      - name: Verify .NET version
        run: dotnet --info

      - name: Test Server (Postman)
        id: postman_tests
        run: |
          set +e  # Don't exit on error
          make test/server/postman
          TEST_EXIT_CODE=$?
          echo "exit_code=$TEST_EXIT_CODE" >> $GITHUB_OUTPUT
          exit 0  # Always succeed so we can upload artifacts and comment
        
      - name: Upload Postman Reports
        uses: actions/upload-artifact@v4
        if: always()  # Upload even if tests failed
        with:
          name: postman-test-reports
          path: |
            reports/newman-report.json
          retention-days: 30

      - name: Parse test results and create PR comment
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            
            try {
              // Read the Newman JSON report
              const reportPath = 'reports/newman-report.json';
              if (!fs.existsSync(reportPath)) {
                console.log('No Newman report found, skipping comment');
                return;
              }
              
              const reportContent = fs.readFileSync(reportPath, 'utf8');
              const report = JSON.parse(reportContent);
              
              const run = report.run;
              const stats = run.stats;
              
              // Calculate summary statistics
              const totalTests = stats.tests.total || 0;
              const passedTests = stats.tests.passed || 0;
              const failedTests = stats.tests.failed || 0;
              const totalRequests = stats.requests.total || 0;
              const passedRequests = stats.requests.passed || 0;
              const failedRequests = stats.requests.failed || 0;
              
              // Get execution details
              const executionTime = run.timings.completed - run.timings.started;
              const executionTimeMs = Math.round(executionTime);
              const executionTimeSec = Math.round(executionTime / 1000 * 10) / 10;
              
              // Get top failures
              const failures = run.failures || [];
              const topFailures = failures.slice(0, 5).map(failure => {
                const source = failure.source || {};
                const error = failure.error || {};
                return `â€¢ **${source.name || 'Unknown'}**: ${error.message || error.test || 'Unknown error'}`;
              }).join('\n');
              
              // Determine overall status
              const testsPassed = failedTests === 0;
              const statusIcon = testsPassed ? 'âœ…' : 'âŒ';
              const statusText = testsPassed ? 'PASSED' : 'FAILED';
              
              // Create the comment body
              const commentBody = `## ${statusIcon} Postman API Tests ${statusText}
              
              **ğŸ“Š Test Summary**
              - **Tests**: ${passedTests}/${totalTests} passed (${Math.round(passedTests/totalTests*100)}%)
              - **Requests**: ${passedRequests}/${totalRequests} passed
              - **Execution Time**: ${executionTimeSec}s
              
              ${failures.length > 0 ? `**ğŸ” Top Failures**\n${topFailures}` : '**ğŸ‰ All tests passed!**'}
              
              ---
              ğŸ“ **Full reports available in build artifacts**
              - [JSON Report](https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})
              
              <sub>ğŸ¤– This comment will be automatically updated on subsequent runs</sub>`;
              
              // Find existing comment to update
              const comments = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number
              });
              
              const botComment = comments.data.find(comment => 
                comment.user.login === 'github-actions[bot]' && 
                comment.body.includes('Postman API Tests')
              );
              
              if (botComment) {
                // Update existing comment
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: botComment.id,
                  body: commentBody
                });
              } else {
                // Create new comment
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  body: commentBody
                });
              }
              
            } catch (error) {
              console.error('Error creating/updating PR comment:', error);
            }

      - name: Fail job if tests failed
        if: steps.postman_tests.outputs.exit_code != '0'
        run: |
          echo "Postman tests failed with exit code ${{ steps.postman_tests.outputs.exit_code }}"
          exit ${{ steps.postman_tests.outputs.exit_code }}
